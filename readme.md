# CompileDataView

Copyright 2021 Moddable Tech, Inc.<BR>
Author: Peter Hoddie<BR>
Revised: February 2, 2021

## Introduction
CompileDataView makes it easier to work with binary data structures in JavaScript. There are two big motivations to use binary data in JavaScript:

- To interoperate with existing binary data, for example to exchange binary data over a network or serial connection and to read and write a binary file format. Both of these scenarios are common for JavaScript code written for embedded systems.
- To reduce memory required for records by storing property values in a compact binary form rather than as dynamically typed JavaScript values. Memory is particularly precious on resource constrained devices.

CompileDataView is designed to be easy to adopt by developers familiar with the C programming language. Both the syntax used to define binary data structures and the JavaScript code used to work with binary data structures are similar to C. C is used as a model because many binary data structures are already defined in C and many developers working in JavaScript on embedded systems already know C.

If you want to start immediately without reading the documentation, you can [use CompileDataView in your browser](https://phoddie.github.io/compileDataView/). If you do read this document, it is valuable to copy the examples from this document and paste them into the web page to explore the various features.

### Example
The introduction of [DataView](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) to JavaScript in ES6 made it possible to read and write binary records, but not pleasant. CompileDataView addresses this by allowing binary data structures to be described using a C-like syntax which is compiled to JavaScript classes. Scripts read and write values to the data structures with code that looks like the C code operating on the same structure.

Using CompileDataView, this C data structure:

```c
struct IntroRecord {
   int32_t a;
   uint8_t b;
   char c;
   float f;
   uint16_t data[4];
};
```

can be naturally accessed in JavaScript:

```js
let i = new IntroView;
i.a = 0x80001234;
i.b = 3;
i.c = "!";
i.f = i.a / i.b;
i.data[2] = 11;
```

To create views like `IntroView`, you provide CompileDataView with description of the binary data structure using a C-like syntax. It generates JavaScript code to implement your data structure. For this example, the description is simply the C `struct` declaration above which generates the following JavaScript:

```js
export class IntroRecord extends DataView {
   constructor(data, offset) {
      if (data)
         super(data, offset ?? 0, 18);
       else
         super(new ArrayBuffer(18));
   }
   get a() {
      return this.getInt32(0, true);
   }
   set a(value) {
      this.setInt32(0, value, true);
   }
   get b() {
      return this.getUint8(4);
   }
   set b(value) {
      this.setUint8(4, value);
   }
   get c() {
      return String.fromCharCode(this.getUint8(5));
   }
   set c(value) {
      return this.setUint8(5, value.charCodeAt());
   }
   get f() {
      return this.getFloat32(6, true);
   }
   set f(value) {
      this.setFloat32(6, value, true);
   }
   get data() {
      return new Uint16Array(this.buffer, this.byteOffset + 10, 8);
   }
   set data(value) {
      for (let i = 0, j = 10; i < 4; i++, j += 2)
         this.setUint16(j, value[i]);
   }
}
```

If the generated code is a little difficult to understand, don't worry: you don't need to understand the generated code to use it.

Notice that the constructor creates an `ArrayBuffer` with six bytes, which is exactly the same size as the C structure. Using dynamically typed JavaScript properties would require at least fifty-two bytes to store the same values. Of course using standard JavaScript properties executes faster and avoids the need for the `IntroView` class. However, where binary data is required or memory is tight, the reduced performance is a practical tradeoff.

The class generated by CompileDataView is designed to be natural to use in JavaScript. It doesn't try to precisely emulate the behavior of C. For example, the `c` property above is a `char` which would be an 8-bit integer in C. In JavaScript, which has a native `String` type, the `c` property is accessed as a string value.

### Running CompileDataView
CompileDataView is [implemented](https://github.com/phoddie/compileDataView/blob/master/compileDataView.js) as a JavaScript module so it can be incorporated into tools as needed. CompileDataView is available to use in a [web page](https://phoddie.github.io/compileDataView/) where you can easily explore its capabilities and generate classes for use in your projects.

Any errors detected in the input file are displayed in a comment at the top of the generated source code. CompileDataView does not stop on the first error found, so more than one error reported may be reported.

### Adding the generated classes to your Moddable SDK project
The source code CompileDataView generates is intended to be used as a JavaScript module. The generated code may be used with any modern JavaScript engine.

If you are working with the Moddable SDK, here are the steps for adding the generated classes to your project as a module.

- Generate module source code using the [web page](https://phoddie.github.io/compileDataView/).
- Copy the source code into a new file, for example `dataviews.js`.
- Add the new module to your manifest. Be sure to include the new module in the `"preload"` section of the manifest. This ensures that the view classes use no RAM and that their property look-ups are as fast as possible.

```
	"modules": {
		"*": [
			"./main",
			"./dataviews"
		]
	},
	"preload": [
		"dataviews"
	]
```

- Import the new module into the modules where they will be used. The following example assumes that the `"dataview"` module exports a view named `IntroView`.

```js
import {IntroView} from "dataviews";
```

### Using the generated classes in your project
There are two ways to use the generated classes in your scripts. The first is to create a new instance of the record. This initializes all values to zero:

```js
let record = new ExampleView;
```

You can then set and get the properties you defined.

The second way is to wrap the view around an existing buffer of data. This is useful when you receive a buffer of data in a known format from a network source or from reading a file. The view constructor, `ExampleView` here supports both the `buffer` and `byteOffset` parameters of the `DataView` constructor. If you have a buffer in the format of `ExampleView`, you can read its contents as follows:

```js
let record = new ExampleView(buffer);
trace(record.a, "\n");
```

If the data begins somewhere inside the `buffer,` but not at offset zero, pass the byte offset as the second parameter:

```js
let record = new ExampleView(buffer, 16);
trace(record.a, "\n");
```

Because views are a fixed size, the constructor does not support the optional third parameter, `byteLength`, of the `DataView` constructor.

To access the binary data of the view, use the `buffer` property as with the underlying `DataView`. For example:

```js
let record = new ExampleView;
record.a = 12;
file.write(record.buffer);
```

## Reference
This section is explains the the binary data format description used by CompileDataView. It is very similar to C, though not identical.

### File structure
A binary data format description contains one or more structures:

```c
struct A {
	uint8_t a;
};
struct B {
	uint32_t b;
};
```

Arrays and bitfields are supported. Unlike C, Bitfields are always unsigned and must be use the type `Uint`:

```c
struct C {
	int16_t c[4];

	Uint c1:4;
	Uint c2:2;
};
```

Anonymous unions may be embedded in a `struct`:

```c
struct D {
	uint8_t kind;
	union {
		A a;
		B b;
		C c;
	};
};
```

Comments begin with `//` and extend to the end of the line. Empty lines are ignored.

The behavior of CompileDataView is controlled using pragmas. For example, use the `endian` pragma to store multi-byte numbers as big-endian values:

```c
#pragma endian(big)
```

> **Note**: The parser in CompileDataView is far from a full C compiler and supports only a small subset of the C language. It is intended to be familiar to C programmers but not to support all C `struct` declarations.

### Configuring CompileDataView
Pragmas control how CompileDataView generates code for properties. All pragmas are optional. The defaults are designed to be reasonable and safe for use on embedded systems.

Pragmas can be changed in mid-file. For example, changing the `endian` pragma, which controls how multi-byte numbers are stored, allows CompileDataView to support obscure data structures that have both big-endian and little-endian values.

#### `extends`
The `extends` pragma defines the name of the class the generated class extends. The default value is `DataView` and it is rarely necessary to use another value. For example, the following pragma

```
#pragma extends(CustomDataView)
```

generates the following class declaration:

```js
class CompiledDataView extends CustomDataView {
...
```

#### `export`
The `export` pragma determines whether the classes generated by CompileDataView are exported. The default is `true` which means the classes are exported. This pragma is useful when the generated code will be included in a module for use by other modules.

```js
export class CompiledDataView extends DataView {
...
```

#### `get` and `set`
The `get` and `set` pragmas control whether the generated class contains getters and/or setters for the defined properties. Both default to `true` which causes both getters and setters to be generated.

Excluding getters or setters generates less code and has no performance impact. This is useful when you know a particular data structure is only used for reading or writing.

#### `endian`
The `endian` pragma controls how multi-byte numeric values are stored. The default is `"little"` for little-endian values. For big-endian values, use `"big"`. Views that are used to only reduce the memory required for properties should not change the `endian` pragma from the default.

The numeric types that `endian` effects are `Float32`, `Float64`, `Int32`, `Uint16`, `Uint32`, `BigInt64`, and `BigUint64`. The `endian` pragma also controls the endianness of multi-byte integers that store bitfields.

#### `pack`
The `pack` pragma controls the alignment of multi-byte numeric values. The default is `16` which causes values to be aligned based on the size the fields they contain. The default is generally compatible with C and safe for all JavaScript operations. Supported values are `1`, `2`, `4`, `8`, and `16`. Passing no argument for pack (`#pragma pack()`) restores the default.

Views that are used only to reduce the memory required for properties may use the default value of `1` which packs thee fields as tightly as possible.

To see how pack works, consider the following data view description:

```c
#pragma pack(1)
#pragma get(false)

struct Pack {
	Uint8 a;
	Uint16 b;
	Uint8 c;
	Uint32 d;
};
```

The code generated uses eight bytes to store the properties:

```js
export class Pack extends DataView {
   constructor(data, offset) {
      if (data)
         super(data, offset ?? 0, 8);
       else
         super(new ArrayBuffer(8));
   }
   set a(value) {
      this.setUint8(0, value);
   }
   set b(value) {
      this.setUint16(1, value, true);
   }
   set c(value) {
      this.setUint8(3, value);
   }
   set d(value) {
      this.setUint32(4, value, true);
   }
}
```

If the `pack` pragma is changed to `4`, the data structure uses twelve bytes of memory.

```js
export class Pack extends DataView {
   constructor(data, offset) {
      if (data)
         super(data, offset ?? 0, 12);
       else
         super(new ArrayBuffer(12));
   }
   set a(value) {
      this.setUint8(0, value);
   }
   set b(value) {
      this.setUint16(2, value, true);
   }
   set c(value) {
      this.setUint8(4, value);
   }
   set d(value) {
      this.setUint32(8, value, true);
   }
}
```

Note that TypedArrays in JavaScript must be aligned to `byteOffset` values that are an integer multiple of their size. Changing `pack` to a value other than the default may result in data structures that generate runtime exceptions. For example, he following declaration puts the `data` Uint32 TypedArray at offset 1.

```c
#pragma pack(1)
struct Fail {
	char c;
	uint32_t data[4];
};
```

When accessed as follows, an exception is generated because the Uint32 TypedArray must be at a `byteOffset` that is a multiple of 4.

```js
let f = new Fail;
f.data[1] = 3;
```

#### `xs`
The `xs` property controls whether CompileDataView generates code targeting the XS JavaScript engine. The default value is `true`. The only difference in generated code is for string (character array) properties, where CompileDataView uses `String.fromArrayBuffer` and `ArrayBuffer.fromString` in place of `TextDecoder` and `TextEncoder` of the web platform.

At this time there is no option to generate code for strings that works for both XS and the web platform, though it is possible.

#### `outputByteLength`
The `outputByteLength` pragma controls whether CompileDataView includes a static `byteLength` property in the generated class with the number of bytes used by the native data structure. Defaults to `false`.

#### `checkByteLength`
The `checkByteLength ` pragma controls whether CompileDataView generates code to confirm that an ArrayBuffer passed to a view constructor is at least as big as the view. Defaults to `true` so the length is checked. Setting this value to `false` is useful for variable views that end with a union. Note that even if the length is not checked, JavaScript guarantees you cannot read or write beyond the end of allocated memory.

#### `json`
The `json` property controls whether CompileDataView generates code for JSON serialization and object initialization. This experimental feature defaults to `false`.  

With `json` enabled, you can serialize binary objects to JSON, even those with embedded views. This is implemented by including `toJSON` methods on the view classes. 

```js
let i = new IntroRecord;
i.a = 12;
i.c = "!";
i.data = [1, 1, 1, 1];
let json = JSON.stringify(i);
```

With `json` enabled, you can also initialized binary objects from JavaScript objects. This is done by adding a static `from` method to the view classes.

```js
let i = IntroRecord.from({
	a: 12,
	c: "!",
	data: [1, 1, 1, 1]
});
```

> **Note**: The `json` feature generates more code, so only enable it if you intend to use the capabilities it provides.
> 
> **Note**: The initialization support works with unions, but serialization does not  support unions. 

### Property types
CompileDataView supports all the types of values provided by `DataView` and adds support for smaller integers using bitfields, arrays of numbers, booleans, characters, and strings.

#### Numbers
All the numeric types defined by `DataView` are available: `Int8`, `Int16`, `Int32`, `Uint8`, `Uint16`, `Uint32`, `BigInt64`, `BigUint64`, `Float32`, and `Float64`.

To match the C language, `DataView` numeric types are also available using standard C type names: `int8_t`, `int16_t`, `int32_t`, `uint8_t`, `uint16_t`, `uint32_t`, `int64_t`, `uint64_t`, `float`, and `double`.

```c
struct Example {
	Int16 a;
	int16_t b;
	
	Float32 c;
	float d;
	
	double e;
	Float64 f;
};
```

#### Arrays of numbers
Fixed length arrays of numeric types are supported. For example, the following defines a four element array of `Int16`:

```c
struct ArrayExample {
	Int16 values[4];
};
```

Array are properties may be set full arrays:

```js
let i = new ArrayExample;
i.values = Int16Array.of(1, 2, 3, 4);
i.values = [1, 2, 3, 4];
```

They may also be set by individual element:

```js
i.values[2] = 11;
```

Reading an array property returns a reference to the data as the corresponding TypedArray. This allows scripts to use TypedArray methods, such as `fill`, on array properties.

```js
i.values.fill(0xff);
```

Each get of a numeric array property creates new TypedArray instance. Where performance is a priority, code should be written to re-use the TypedArray instance.

```js
for (let j = 0, values = i.values; j < 4; j++)
   values[j] = j;
```

#### Numeric bitfields
Numeric bitfields are unsigned integer values of 1 to 31 bits. CompileDataView merges sequential bitfields into a single integer to reduce memory use.

Numeric bitfields are declared using the `Uint` type and adopting C-style bitfield declarations:

```c
struct BitFields {
	Uint oneBit:1;
	Uint nybble:4;
	Uint mask:3;
};
```

This declaration uses only one byte of storage.

Bitfields and arrays are mutually exclusive: you cannot have an array of `Uint` values.

#### Boolean
Boolean values allow JavaScript `true` and `false` values to be stored in a `DataView`. Boolean values are treated as a bitfield with a size of one bit. When setting the property, a truthy value is 1; when reading, the return values are `true` and `false`.

```c
struct Booleans {
	Boolean a;
	boolean b
	bool c;
};
```

Because Booleans are implemented as bitfields, arrays of Booleans are not supported.

#### Characters
JavaScript does not have a data type for a single character but because the `char` type is common in C, CompileDataView supports it:

```c
struct Character {
	char c;
};
```

The `char` type uses one byte of storage, a `Uint8` type. If the character value to be stored is greater than 255, only the low eight bits are stored. To set a character property, pass a string. The first character is stored.

```js
i.c = "a";
```

The result of reading a `char` a one character string, not an integer as in C.

#### Strings
CompileDataView supports strings using an array of `char`. The following declares a string of 8 bytes:

```c
struct StringExample {
	char str[8];
};
```

Note that this is 8 bytes, not 8 JavaScript Unicode characters. Strings are stored in UTF-8 format.

You may set strings values shorter than the declared length, but not longer.

```js
let i = new StringExample;
i.str = "12345678"; // ok
i.str = "12"; // ok
i.str = "123456789"; // throws
```

#### Embedded Types
View declared in a description can be embedded in views that follow it by using the class name as the type.

```c
struct Point {
	uint16_t x;
	uint16_t y;
};

struct Rectangle {
	Point topLeft;
	Point bottomRight;
};
```

The generated classes may be used by scripts.

```js
let r = new Rectangle;

r.topLeft.x = 10;
r.topLeft.y = 20;

r.bottomRight = r.topLeft;
r.bottomRight.x += 5;
r.bottomRight.y += 5;
```

Like numeric arrays, getting the value of an embedded type returns a new instance of the view referencing the original data. Therefore, it is similarly recommended to reuse the returned instance when practical.

## Past and future
I have used this technique of extending `DataView` with getters and setters in several projects. Each time I wrote the getters and setters by hand. It isn't very difficult to do, though bitfields are a bit tedious and making changes to the data structures requires time-consuming renumbering of offsets. I wrote about this technique in the "JavaScript For Embedded C and C++ Programmers" chapter in the book "[IoT Development for ESP32 and ESP8266 with JavaScript](https://moddable.com/book)" (pages 116 to 118) together with Lizzie Prader.

CompileDataView is a weekend project to automate the technique. It applies approaches that worked well in the hand-rolled efforts.

There are some other libraries with a similar goal of simplifying access to native data structures with JavaScript's `DataView`. To use these libraries, if I recall correctly, the developer writes JavaScript to define the data structures. Those are then used to generate JavaScript classes at runtime. That makes good sense in the browser and Node.js, but is impractical on embedded systems. The approach CompileDataView takes offloads the code generation from the embedded device. I also like the idea of using a C-like syntax to define the data structures since many developers working in embedded have a background in C.

As a quick project, CompileDataView is a little rough. I know little about writing parsers and less about building web pages. The parser is adequate, but the [web page](https://phoddie.github.io/compileDataView/) could really use some help (hint, hint).

While CompileDataView is useful today, there are areas that could be explored further.
 
- **Initializers**: In some data structures, some properties should be initialized to a non-zero value. This could be done with the syntax `Int8 foo = 1;` with the assignment applied in the constructor.
- **ASCII strings**: The `string` type stores UTF-8 which is useful, but 8-bit character data is common enough in many binary formats that it makes sense to support directly.
- **Date**: It might be useful to allow `Date` objects to be stored directly, as Booleans are.
- **Code generation**: The code for copying structures and strings could be optimized based on the size of the copy.

## Acknowledgements
The motivation for creating CompileDataView was code kindly shared in the [Embedded JavaScript Gitter](https://gitter.im/embedded-javascript/moddable) by an embedded developer ([@SkyeSweeney](https://github.com/SkyeSweeney)) writing their first JavaScript code.

The original syntax of the binary data descriptions was unnecessarily complex. Thanks to Patrick Soquet for encouraging me to follow the C model more closely.

## Contact
If you run into an issue or have question, please post it to the [CompileDataView repository](https://github.com/phoddie/compileDataView). You can also reach me on Twitter at [@phoddie](https://twitter.com/phoddie). Pull requests with improvements are welcome.
