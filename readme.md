# CompileDataView

Copyright 2021 Moddable Tech, Inc.<BR>
Author: Peter Hoddie<BR>
Revised: January 24, 2021

## Introduction
CompileDataView makes it easier to work with binary data structures in JavaScript. There are two big motivations to use binary data in JavaScript:

- To interoperate with existing binary data, for example to exchange binary data over a network or serial connection and to read and write a binary file format. Both of these scenarios are common for JavaScript code written for embedded systems.
- To reduce memory required for records by storing property values in a compact binary form rather than as dynamically typed JavaScript values. Memory is particularly precious on resource constrained devices.

### Example
The introduction of [DataView](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) to JavaScript in ES6 made it possible to read and write binary records, but not pleasant. Using CompileDataView, this C data structure:

```c
struct IntroRecord {
   int32_t a;
   uint8_t b;
   char c;
};
```

can be naturally accessed in JavaScript:

```
let i = new IntroView;
i.a = 0x80001234;
i.b = 1;
i.c = "!";
let d = (i.a + i.b) + i.c;
```

To create views like `IntroView`, you provide CompileDataView with description of the binary data structure using a C-like syntax. It generates JavaScript code to implement your data structure. This is the description for the example above:

```
class: IntroView;

Int32 a;
Uint8 b;
char c;
```

This is the generated class:

```js
class IntroView extends DataView {
   constructor(data, offset) {
      if (data)
         super(data, offset ?? 0, 6);
       else
         super(new ArrayBuffer(6));
   }
   get a() {
      return this.getInt32(0, true);
   }
   set a(value) {
      this.setInt32(0, value, true);
   }
   get b() {
      return this.getUint8(4);
   }
   set b(value) {
      this.setUint8(4, value);
   }
   get c() {
      return String.fromCharCode(this.getUint8(5));
   }
   set c(value) {
      return this.setUint8(5, value.charCodeAt());
   }
}
```

If the generated code is a little difficult to understand, don't worry: you don't need to understand the generated code to use it.

Notice that the constructor creates an `ArrayBuffer` with six bytes, which is exactly the same size as the C structure. Using dynamically typed JavaScript properties would require at least fifty-two bytes to store the same values. Of course using standard JavaScript properties executes faster and avoids the need for the `IntroView` class. However, where binary data is required or memory is tight, the reduced performance is a practical tradeoff.

The class generated by CompileDataView is designed to be natural to use in JavaScript. It doesn't try to precisely emulate the behavior of C. For example, the `c` property above is a `char` which would be an 8-bit integer in C. In JavaScript, which has a native `String` type, the `c` property is accessed as a string value.

### Running CompileDataView
CompileDataView is [implemented](https://github.com/phoddie/compileDataView/blob/master/compileDataView.js) as a JavaScript module so it can be incorporated into tools as needed. CompileDataView is available to use in a [web page](https://phoddie.github.io/compileDataView/) where you can easily explore its capabilities and generate classes for use in your projects.

Any errors detected in the input file are displayed in a comment at the top of the generated source code. CompileDataView does not stop on the first error found, so  more than one error reported may be reported.

### Using the generated class in your project
You can copy the code generated by the CompileDataView [web page](https://phoddie.github.io/compileDataView/) into your project. There are two ways to use it. The first is to create a new instance of the record. This initializes all values to zero:

```js
let record = new ExampleView;
```

You can then set and get the properties you defined.

The second way is to wrap the view around an existing buffer of data. This is useful when you receive a buffer of data in a known format from a network source or from reading a file. The view constructor, `ExampleView` here supports both the `buffer` and `byteOffset` parameters of the `DataView` constructor. If you have a buffer in the format of `ExampleView`, you can read its contents as follows:

```js
let record = new ExampleView(buffer);
trace(record.a, "\n");
```

If the data begins somewhere inside the `buffer,` but not at offset zero, pass the byte offset as the second parameter:

```js
let record = new ExampleView(buffer, 16);
trace(record.a, "\n");
```

Because views are a fixed size, the constructor does not support the optional third parameter, `byteLength`, of the `DataView` constructor.

To access the binary data of the view, use the `buffer` property as with the underlying `DataView`. For example:

```js
let record = new ExampleView;
record.a = 12;
file.write(record.buffer);
```

## Reference
This section is explains the the binary data format description used by CompileDataView.

### Line-based structure
CompileDataView recognizes the following kinds of lines:

- **Property definition**: define one property in the generated view. They begin with the name of a supported type followed by a space and then the property name and a semicolon, such as `Int32 value;`. For an array, the element count follows the property name, `Int32 values[2];` For bitfields, the bit count follows the property name, `Uint oneBit:1;`
- **Setting**: control the behavior of CompileDataView. They begin with the name of a setting followed by a colon, then then property value, and finally a semicolon, such as `class: Example;`.
- **Comment**: ignored. These lines begin with `//`.

Empty lines are ignored.

A comment, starting with `//`, may appear after the semicolon on property definition and setting lines.

### Settings
Settings control how CompileDataView generates code for properties. All settings are optional. The defaults are designed to be reasonable and safe for use on embedded systems.

Setting can be changed in mid-file. For example, changing the `endian` setting, which controls how multi-byte numbers are stored, allows CompileDataView to support obscure data structures that have both big-endian and little-endian values.

#### `class`
The `class` setting defines the name of the generated class. The default value is `CompiledDataView`. For example, the following setting

```
class: ExampleView;
```

generates the following class declaration:

```js
class ExampleView extends DataView {
...
```

The `class` setting may be used to define more than one class in a single description. If the `class` setting appears after any properties have been declared, it causes the current class to be output and a new class to new started with the name specified. The following outputs two classes, `AView` and `BView`:

```
class AView
Uint32 a;

class BView
Uint16 b;
```

#### `extends`
The `extends` setting defines the name of the class the generated class extends. The default value is `DataView` and it is rarely necessary to use another value. For example, the following setting

```
extends: CustomDataView;
```

generates the following class declaration:

```js
class CompiledDataView extends CustomDataView {
...
```

#### `export`
The `export` setting determines whether the classes generated by CompileDataView are exported. The default is `false` which means the classes are not exported. This setting is useful if the generated code will be included in a module for use by other modules.

```js
export class CompiledDataView extends DataView {
...
```

#### `get` and `set`
The `get` and `set` settings control whether the generated class contains getters and/or setters for the defined properties. Both default to `true` which causes both getters and setters to be generated.

Excluding getters or setters generates less code and has no performance impact. This is useful when you know a particular data structure is only used for reading or writing.

#### `endian`
The `endian` setting controls how multi-byte numeric values are stored. The default is `"little"` for little-endian values. For big-endian values, use `"big"`. Views that are used to only reduce the memory required for properties should not change the `endian` setting from the default.

The numeric types that `endian` effects are `Float32`, `Float64`, `Int32`, `Uint16`, `Uint32`, `BigInt64`, and `BigUint64`.  The `endian` setting also controls the endianness of multi-byte integers that store bitfields.

#### `pack`
The `pack` setting controls the alignment of multi-byte numeric values. The default is `true` which causes values to be organized sequentially without any unused bytes between them. When `pack` is set to `false`, two-byte integers are forced to an even offset; four- and eight-byte integers are forced to a four-byte alignment.

Views that are used only to reduce the memory required for properties should use the default value of `true`. The alignment option is provided to match the behavior of `struct` definitions in C to ease interoperation with native code.

Consider the following data view description:

```
pack: true;
get: false;

Uint8 a;
Uint16 b;
Uint8 c;
Uint32 d;
```

The code generated uses eight bytes to store the properties:

```js
class CompiledDataView extends DataView {
   constructor(data, offset) {
      if (data)
         super(data, offset ?? 0, 8);
       else
         super(new ArrayBuffer(8));
   }
   set a(value) {
      this.setUint8(0, value);
   }
   set b(value) {
      this.setUint16(1, value, true);
   }
   set c(value) {
      this.setUint8(3, value);
   }
   set d(value) {
      this.setUint32(4, value, true);
   }
}
```

If the `pack` setting is changed to `false`, the data structure uses twelve bytes of memory.

```js
class CompiledDataView extends DataView {
   constructor(data, offset) {
      if (data)
         super(data, offset ?? 0, 12);
       else
         super(new ArrayBuffer(12));
   }
   set a(value) {
      this.setUint8(0, value);
   }
   set b(value) {
      this.setUint16(2, value, true);
   }
   set c(value) {
      this.setUint8(4, value);
   }
   set d(value) {
      this.setUint32(8, value, true);
   }
}
```

#### `xs`
The `xs` property controls whether CompileDataView generates code targeting the XS JavaScript engine. The default value is `true`. The only difference in generated code is for string (character array) properties, where CompileDataView uses `String.fromArrayBuffer` and `ArrayBuffer.fromString` in place of `TextDecoder` and `TextEncoder` of the web platform.

At this time there is no option to generate code for strings that works for both XS and the web platform, though it is possible.

#### `byteLength`
The `byteLength` setting controls whether CompileDataView includes a static `byteLength` property in the generated class with the number of bytes used by the native data structure. Defaults to `false`.

### Property types
CompileDataView supports all the types of values provided by `DataView` and adds support for smaller integers using bitfields, arrays of numbers, booleans, characters, and strings.

#### Numbers
The numeric types defined by `DataView` are all available: `Int8`, `Int16`, `Int32`, `Uint8`, `Uint16`, `Uint32`, `BigInt64`, `BigUint64`, and `Float32`, `Float64`.

```
Int16 value;
Float32 single;
Float64 double;
```

#### Arrays of numbers
Fixed length arrays of numeric types are supported. For example, the following defines a four element array of `Int16`:

```
Int16 values[4];
```

Arrays properties are accessed as full arrays, not by individual element. To set a value in the array, set the array:

```
i.values = Int16Array.of(1, 2, 3, 4);
i.values = [1, 2, 3, 4];
```

Reading an array property returns a copy of the array as the corresponding TypedArray.

```
let values = i.values;	// values is an instance of Int16Array
let first = values[0];
```

> Note: A future option could allow array access by reference instead of by copy. By avoiding a copy on get this would be faster and more memory efficient. However, it could also lead to unpleasant surprises if not used with care.

#### Numeric bitfields
Numeric bitfields are unsigned integer values of 1 to 31 bits. CompileDataView merges sequential bitfields into a single integer to reduce memory use.

Numeric bitfields are declared using the `Uint` type and adopting C-style bitfield declarations:

```
Uint oneBit:1;
Uint nybble:4;
Uint mask:3;
```

This declaration uses only one byte of storage.

Bitfields and arrays are mutually exclusive: you cannot have an array of `Uint` values.

#### Boolean
Boolean values allow JavaScript `true` and `false` values to be stored in a `DataView`. Boolean values are treated as a bitfield with a size of one bit. When setting the property, a truthy value is 1; when reading, the return values are `true` and `false`.

```
Boolean on;
```

Because Booleans are implemented as bitfields, arrays of Booleans are not supported.

#### Characters
JavaScript does not have a data type for a single character but because the `char` type is common in C, CompileDataView supports it:

```
char c;
```

The `char` type uses one byte of storage, a `Uint8` type. If the character value to be stored is greater than 255, only the low eight bits are stored. To set a character property, pass a string. The first character is stored.

```js
i.c = "a";
```

The result of reading a `char` a one character string, not an integer as in C.

#### Strings
CompileDataView supports strings using an array of `char`. The following declares a string of 8 bytes:

```
char str[8];
```

Note that this is 8 bytes, not 8 JavaScript Unicode characters. Strings are stored in UTF-8 format.

You may set strings values shorter than the declared length, but not longer.

```js
i.str = "12345678"; // ok
i.str = "12"; // ok
i.str = "123456789"; // throws
```

## Past and future
I have used this technique of extending `DataView` with getters and setters in several projects. Each time I wrote the getters and setters by hand. It isn't very difficult to do, though bitfields are a bit tedious and making changes to the data structures requires time-consuming renumbering of offsets. I wrote about this technique in the "JavaScript For Embedded C and C++ Programmers" chapter in the book "[IoT Development for ESP32 and ESP8266 with JavaScript](https://moddable.com/book)" (pages 116 to 118) together with Lizzie Prader.

CompileDataView is a weekend project to automate the technique. It applies approaches that worked well in the hand-rolled efforts.

There are some other libraries with a similar goal of simplifying access to native data structures with JavaScript's `DataView`. To use these libraries, if I recall correctly, the developer writes JavaScript to define the data structures. Those are then used to generate JavaScript classes at runtime. That makes good sense in the browser and Node.js, but is impractical on embedded systems. The approach CompileDataView takes offloads the code generation from the embedded device. I also like the idea of using a C-like syntax to define the data structures since many developers working in embedded have a background in C.

As a quick project, CompileDataView is a little rough. I know little about writing parsers and less about building web pages. The parser is adequate, but the web page could really use some help (hint, hint).

CompileDataView is useful as-is. There are areas that could be explored further.
 
- **Initializers**: In some data structures, some properties should be initialized to a non-zero value. This could be done with the syntax `Int8 foo = 1;` with the assignment applied in the constructor.
- **ASCII strings**: The `string` type stores UTF-8 which is useful, but 8-bit character data is common enough in many binary formats that it makes sense to support directly.
- **Date**: It might be useful to allow `Date` objects to be stored directly, as  Booleans are.
- **Get array by reference**: Array properties are retrieved by value. It would be more efficient in some cases to return them by reference.
- **Nested data structures**: It would be useful to allow one native data structures to include another.

If you run into an issue or have question, please post it to the [CompileDataView repository](https://github.com/phoddie/compileDataView). You can also reach me on Twitter at [@phoddie](https://twitter.com/phoddie). Pull requests with improvements are welcome.
